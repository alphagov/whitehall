require "gds_api/helpers"

class EmailTopicChecker
  include GdsApi::Helpers

  # The govuk-delivery mongo db stores absolute paths for feed_urls in its
  # db.topics collection. This environment variable lets us swap out the feed
  # urls generated by Whitehall to match the origin host.
  ORIGIN = URI.parse(ENV.fetch("ORIGIN", "https://www.gov.uk"))

  # We make a request to the content store to look up the supertypes for the
  # document as these are used in email-alert-api's SubscriberListQuery. Set
  # this environment variable to skip this check. This is useful if you don't
  # have any data in your local content store and still want the code to run.
  IGNORE_SUPERTYPES = ENV["IGNORE_SUPERTYPES"].present?

  attr_accessor(
    :document,
    :edition,
    :presenter,
    :content,
    :links,
    :verbose,
    :feed_urls,
    :params,
  )

  def initialize(document, verbose: true)
    self.edition = edition = document.published_edition
    raise "No published edition" unless edition

    # Force pre-evaluation so we don't make database calls in rake task threads.
    self.feed_urls = generate_feed_urls(edition)
    self.presenter = PublishingApiPresenters.presenter_for(edition)
    self.content = presenter.content
    self.links = presenter.links
    self.verbose = verbose
  end

  def check
    supertypes = content_store_supertypes

    govuk_topics = feed_urls.map { |url| govuk_delivery_topic(url) }.compact.sort
    email_topics = email_alert_api_topics(supertypes)

    additional_govuk = (govuk_topics - email_topics)
    additional_email = (email_topics - govuk_topics)

    if verbose
      <<-OUTPUT.strip_heredoc
      govuk-delivery feed urls:
      #{feed_urls.join("\n")}

      email-alert-api params:
      #{params.inspect}

      govuk-delivery topics:
      #{govuk_topics.join("\n")}

      email-alert-api topics:
      #{email_topics.join("\n")}

      additional govuk-delivery topics:
      #{additional_govuk.any? ? additional_govuk.join("\n") : 'None'}

      additional email-alert-api topics:
      #{additional_email.any? ? additional_email.join("\n") : 'None'}
      OUTPUT
    elsif additional_govuk.any?
      edition.content_id
    end
  end

  def govuk_delivery_topic(feed_url)
    feed_uri = URI.parse(feed_url)
    feed_uri.scheme = ORIGIN.scheme
    feed_uri.host = ORIGIN.host

    signup_url = Whitehall.govuk_delivery_client.signup_url(feed_uri.to_s)
    signup_uri = URI.parse(signup_url)
    signup_params = CGI.parse(signup_uri.query)

    signup_params.fetch("topic_id").first
  rescue GdsApi::HTTPNotFound
    nil
  end

  def content_store_supertypes
    return {} if IGNORE_SUPERTYPES

    base_path = content.to_h.fetch(:base_path)
    content = Whitehall.content_store.content_item(base_path).to_h
    if content["content_id"] != presenter.content_id
      raise "content store returned different content item"
    end
    content.slice("email_document_supertype", "government_document_supertype").symbolize_keys
  end

  def email_alert_api_topics(supertypes)
    details = content[:details]
    tags = details[:tags] if details

    self.params = {
      links: strip_empty_arrays(links || {}),
      tags: strip_empty_arrays(tags || {}),
      document_type: content[:document_type],
    }.merge(supertypes)

    response = email_alert_api.topic_matches(params)
    response.to_h.fetch("topics")
  rescue GdsApi::HTTPNotFound
    nil
  end

  def generate_feed_urls(edition)
    generator = Whitehall::GovUkDelivery::SubscriptionUrlGenerator.new(edition)
    urls = generator.subscription_urls

    # Ignore an issue with consultations that we've already captured:
    # https://trello.com/c/CF0yJf2F
    # https://trello.com/c/qv1l3WBy
    if ENV["IGNORE_CONSULTATIONS_ISSUE"]
      urls = urls.reject { |url| url.include?("publication_filter_option=consultations") }
    end

    urls
  end

  def strip_empty_arrays(hash)
    hash.reject { |_, values| values.empty? }
  end
end
